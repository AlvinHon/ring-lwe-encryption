use rand::rng;
use rlwe_encryption::{key_gen, standard, IntField, Message};

macro_rules! define_zq_i64 {
    ($name:ident, $q:expr) => {
        #[derive(Clone, Debug)]
        struct $name;

        impl IntField for $name {
            type I = i64;
            const Q: i64 = $q;
            const B: i64 = 1;

            fn modulo(x: &Self::I) -> Self::I {
                let a = x.rem_euclid(Self::Q);
                if a > Self::Q / 2 {
                    a - Self::Q
                } else {
                    a
                }
            }
        }
    };
}

/// Test the encryption scheme with random messages. The keys are generated by the standard method.
#[test]
fn test_standard() {
    let rng = &mut rng();
    let (ek, dk) = standard(rng);

    for _ in 0..100 {
        let message = Message::random(rng, 256);
        let c = ek.encrypt(rng, message.clone());
        let m = dk.decrypt(c)[..message.len()].to_vec();
        assert_eq!(message.data(), m);
    }
}

/// Test the encryption scheme with random messages. The keys are generated with parameters N=512, Q=8383489.
#[test]
fn test_key_gen_q8383489_n512() {
    define_zq_i64!(ZqI64_8383489, 8383489);

    let rng = &mut rng();
    let (ek, dk) = key_gen::<ZqI64_8383489, 512>(rng);

    for _ in 0..100 {
        let message = Message::random(rng, 512);
        let c = ek.encrypt(rng, message.clone());
        let m = dk.decrypt(c)[..message.len()].to_vec();
        assert_eq!(message.data(), m);
    }
}

/// Test the encryption scheme with random messages. The keys are generated with parameters N=1024, Q=16760833.
#[test]
fn test_key_gen_q16760833_n1024() {
    define_zq_i64!(ZqI64_16760833, 16760833);

    let rng = &mut rng();
    let (ek, dk) = key_gen::<ZqI64_16760833, 1024>(rng);

    for _ in 0..100 {
        let message = Message::random(rng, 1024);
        let c = ek.encrypt(rng, message.clone());
        let m = dk.decrypt(c)[..message.len()].to_vec();
        assert_eq!(message.data(), m);
    }
}

#[test]
#[cfg(feature = "serde")]
fn test_serde() {
    let rng = &mut rng();
    let (ek, dk) = standard(rng);
    let message = Message::random(rng, 256);

    let serialized_ek = bincode::serialize(&ek).unwrap();
    // - bincode treats usize as u64 (8 bytes), and adds 8 bytes for the length of the vector
    // - size of i32 = 4
    // - 2 polynomials, each with at most 256 coefficients
    // => 2 * (8 + 256 * 4) = 2064
    assert!(serialized_ek.len() <= 2064);
    let deserialized_ek = bincode::deserialize(&serialized_ek).unwrap();
    assert_eq!(ek, deserialized_ek);

    let serialized_dk = bincode::serialize(&dk).unwrap();
    // DecryptKey only has one polynomial
    // => 8 + 256 * 4 = 1032
    assert!(serialized_dk.len() <= 1032);
    let deserialized_dk = bincode::deserialize(&serialized_dk).unwrap();
    assert_eq!(dk, deserialized_dk);

    let c = ek.encrypt(rng, message.clone());
    let serialized_c = bincode::serialize(&c).unwrap();
    // again, ciphertext has 2 polynomials, each with 256 coefficients
    assert!(serialized_c.len() <= 2064);
    let deserialized_c = bincode::deserialize(&serialized_c).unwrap();
    assert_eq!(c, deserialized_c);
}
