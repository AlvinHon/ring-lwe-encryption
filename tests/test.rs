use rand::{rng, Rng};
use rlwe_encryption::{key_gen, standard, IntField};

/// Test the encryption scheme with random messages. The keys are generated by the standard method.
#[test]
fn test_standard() {
    let rng = &mut rng();
    let (ek, dk) = standard(rng);

    for _ in 0..100 {
        let message = (0..256)
            .map(|_| rng.random_range(0..2))
            .collect::<Vec<i32>>();
        let c = ek.encrypt(rng, message.clone());
        let m = dk.decrypt(c)[..message.len()].to_vec();
        assert_eq!(message, m);
    }
}

/// Test the encryption scheme with random messages. The keys are generated with parameters N=512, Q=8383489.
#[test]
fn test_key_gen_q8383489_n512() {
    struct ZqI64;

    impl IntField for ZqI64 {
        type I = i64;
        const Q: i64 = 8383489;
        const B: i64 = 1;

        fn modulo(x: &Self::I) -> Self::I {
            let a = x.rem_euclid(Self::Q);
            if a > Self::Q / 2 {
                a - Self::Q
            } else {
                a
            }
        }
    }

    let rng = &mut rng();
    let (ek, dk) = key_gen::<ZqI64, 512>(rng);

    for _ in 0..100 {
        let message = (0..512)
            .map(|_| rng.random_range(0..2))
            .collect::<Vec<i64>>();
        let c = ek.encrypt(rng, message.clone());
        let m = dk.decrypt(c)[..message.len()].to_vec();
        assert_eq!(message, m);
    }
}

/// Test the encryption scheme with random messages. The keys are generated with parameters N=1024, Q=16760833.
#[test]
fn test_key_gen_q16760833_n1024() {
    struct ZqI64;

    impl IntField for ZqI64 {
        type I = i64;
        const Q: i64 = 16760833;
        const B: i64 = 1;

        fn modulo(x: &Self::I) -> Self::I {
            let a = x.rem_euclid(Self::Q);
            if a > Self::Q / 2 {
                a - Self::Q
            } else {
                a
            }
        }
    }

    let rng = &mut rng();
    let (ek, dk) = key_gen::<ZqI64, 1024>(rng);

    for _ in 0..100 {
        let message = (0..1024)
            .map(|_| rng.random_range(0..2))
            .collect::<Vec<i64>>();
        let c = ek.encrypt(rng, message.clone());
        let m = dk.decrypt(c)[..message.len()].to_vec();
        assert_eq!(message, m);
    }
}

#[test]
#[cfg(feature = "serde")]
fn test_serde() {
    let rng = &mut rng();
    let (ek, dk) = standard(rng);
    let message = (0..256)
        .map(|_| rng.random_range(0..2))
        .collect::<Vec<i32>>();

    let serialized_ek = bincode::serialize(&ek).unwrap();
    // - bincode treats usize as u64 (8 bytes), and adds 8 bytes for the length of the vector
    // - size of i32 = 4
    // - 2 polynomials, each with at most 256 coefficients
    // => 2 * (8 + 256 * 4) = 2064
    assert!(serialized_ek.len() <= 2064);
    let deserialized_ek = bincode::deserialize(&serialized_ek).unwrap();
    assert_eq!(ek, deserialized_ek);

    let serialized_dk = bincode::serialize(&dk).unwrap();
    // DecryptKey only has one polynomial
    // => 8 + 256 * 4 = 1032
    assert!(serialized_dk.len() <= 1032);
    let deserialized_dk = bincode::deserialize(&serialized_dk).unwrap();
    assert_eq!(dk, deserialized_dk);

    let c = ek.encrypt(rng, message.clone());
    let serialized_c = bincode::serialize(&c).unwrap();
    // again, ciphertext has 2 polynomials, each with 256 coefficients
    assert!(serialized_c.len() <= 2064);
    let deserialized_c = bincode::deserialize(&serialized_c).unwrap();
    assert_eq!(c, deserialized_c);
}
